-- bakery

specs:   	modal
constructs:	idle wait crit safe
defuncts:       start filterP updMin
preds:		anyP allP Safe

axioms:

  (anyP(P)$st <==> any(P.(st!!))$procs)	  -- procs = indices$st, here: tickets

& (allP(P)$st <==> all(P.(st!!))$procs)

& filterP(P)$st == filter(P.(st!!))$procs

& updMin(st)(x,y) == upd(st)(min$filterP(=x)$st)$y

& start == replicate(noProcs)$idle 	  -- = take(noProcs)$mu s.(idle:s)

& states == [start]

& (anyP(=idle)$st ==> st -> updMin(st)(idle,wait))	-- min idle waits	
	 
& (anyP(=wait)$st & allP(=/=crit)$st 
		  ==> st -> updMin(st)(wait,crit))	-- min wait enters	 
& (anyP(=crit)$st ==> st -> updMin(st)(crit,idle))	-- crit leaves	

-- 2 processes (= tickets) yield 8 states
-- 3 processes yield 19 states

& atoms == [safe]

& (Safe <==> (<=1).length.filterP(=crit))

& safe -> valid$Safe

conjects:

  EX(true)$start	--> True        9 simplification steps
& states = eval$EX$true --> True
& AG(Safe)$start	--> True	coinduction + narrowing

terms:

    eval$EX$true	--> states 
<+> eval$AG$safe	--> states
-- reglangs

constructs: 	a b c final q qa qb qab qbb qabb q' qa' qb' qab' qgg 
		qug qgu quu 
defuncts:	delta beta unfold unfoldND unfoldBro reg drawL drawC
preds:          Unfold
fovars: 	st st' w k

axioms:

labels == [a,b] & atoms == [final] & 

-- acceptors of words with an even number of a's and an odd number of b's 
-- if started in q or q'

states == [q] & final -> qb<+>qb' &

(q,a) -> qa     & (q,b) -> qb      & 
(qa,a) -> q     & (qa,b) -> qab    &
(qb,a) -> qab   & (qb,b) -> qbb    & 
(qab,a) -> qb   & (qab,b) -> qabb  &
(qbb,a) -> qabb & (qbb,b) -> qb    &
(qabb,a) -> qbb & (qabb,b) -> qab  & 

(q',a) -> qa'   & (q',b) -> qb'    & 		-- minimized version
(qa',a) -> q'   & (qa',b) -> qab'  &
(qb',a) -> qab' & (qb',b) -> q'    &
(qab',a) -> qb' & (qab',b) -> qa'  &

-- acceptor of words with an even number of a's and an even number of b's 
-- if started in qgg

-- states == [qgg] & final -> qgg &

(qgg,a) -> qug & (qgg,b) -> qgu &
(qug,a) -> qgg & (qug,b) -> quu &
(quu,a) -> qgu & (quu,b) -> qug &
(qgu,a) -> quu & (qgu,b) -> qgg &

(Unfold(st)[]    <=== final -> st) &		
(Unfold(st)(x:w) <=== (st,x) -> st' & Unfold(st')$w) &

unfoldND$s == out <=< kfold(flip$transL)$s &	-- nondeterministic unfold
						-- (for kfold see base)
delta(st,x) == head$transL(st)$x &		
beta$st == ite(null$out$st,0,1) &

unfold(st) == beta.foldl(delta)(st) & 		-- deterministic unfold

-- Examples

reg$1 == star$plus(a)+plus(b*c) & 	

reg$2 == a+a*a*star(a)*b+a*b*star(b)+b &	--> star(a)*b+a*star(b)

reg$3 == a+star(a)+eps+a & 			--> star(a) 

reg$4 == (a+eps)*star(a)*(eps+a) &		--> star(a)

reg$5 == a*b+a*a+a*h+b*c+b*d &			--> a*(b+a+h)+b*(c+d)

reg$6 == d*pp+c*h*z+a*b+c+a+a*b*c*d+star(a*a+b+a*b)+mt+c*t+b*gg+eps+
         a+a*a+vv+a*a*8+d+b &
	--> (a*a*8)+a+c+d+(a*b*c*d)+(b*gg)+(d*pp)+(c*t)+vv+(c*h*z
            +star((a*(a+b))+b)

reg$7 == a+((star(b)*a)+((a+(star(b)*a))*star(a+(b+mt)))) &	
	--> star(b)*a*star(a+b)			-- auto3

reg$8 == (a+c+eps+((a+c+eps)*(star(a+c+eps)*(a+c+eps))))+
         ((b+((a+c+eps)*(star(a+c+eps)*b)))*(star(a+b+eps+
         (c*(star(a+c+eps)*b)))*(c+(c*(star(a+c+eps)*(a+c+eps)))))) &
        --> star(a+c)+(star(a+c)*b*star(a+b+(c*star(a+c)*b))*c*star(a+c))
						-- auto4

reg$9 == star(a)*b+c+star(a) &			--> star(a)*(eps+b)+c

-- widget interpreters

drawL == wtree(1,fun((eps,k,n),text$eps,
                     (st,k,n),ite(Int$st,
				  color(k,n)$circ$11,
				  frame$blue$text$st))) &

drawC == wtree $ fun(eps,gif(cat,16,14),x,text$x) 

conjects:

Unfold(q)[] &			--> False	-- unify&narrow&
Unfold(q)[b] &			--> True	-- derive&simplify&refute
Unfold(q)[b,b] &		--> False
Unfold(q)[a,b,a,b,a,b,a] &	--> True	-- reglangs1
Unfold(q)[a,b,a,b,b,a,b,a] &	--> False
Unfold(q)[a,b,a,a,b,a] &	--> False
Unfold(q)[a,b,a,a,b,a,b] &	--> True

q~q' 				--> True

terms:

unfoldND[q][] <+>			--> []		-- simplify
unfoldND[q][b] <+>			--> [final]
unfoldND[q][b,b] <+>			--> []
unfoldND[q][a,b,a,b,a,b,a] <+>		--> [final]
unfoldND[q][a,b,a,b,b,a,b,a] <+>	--> []
unfoldND[q][a,b,a,a,b,a] <+>		--> []		-- 39 steps
unfoldND[q][a,b,a,a,b,a,b] <+>		--> [final]	-- 45 steps

unfold(q)[a,b,a,a,b,a] <+>		--> 0		-- 23 steps
unfold(q)[a,b,a,a,b,a,b] <+>		--> 1		-- 26 steps

unfold(qgg)[a,b,a,a,b] <+>		--> 0		-- 22 steps
unfold(qgg)[a,b,a,a,b,a] <+>		--> 1		-- 25 steps

unfoldBro[](reg$2)[a,a,a,b] <+>		--> 1
unfoldBro[](reg$2)[a,a,a,b,b] <+>	--> 0

auto$reg$1 <+>			--> non-deterministic acceptor of reg1 
pauto$reg$1 			--> deterministic acceptor of reg1   

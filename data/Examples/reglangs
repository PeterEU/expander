-- reglangs

specs: 		modal
constructs: 	a b final q qa qb qab qbb qabb 
defuncts:	drawL drawC reg
preds:   	unfold UNFOLD Sat
copreds: 	#
fovars: 	w k

axioms:

reg == star$plus(a)+plus(b*c) & 	-- regular expression (a^++(bc)^+)*

-- acceptor of words with an even number of a's  and an odd number of b's

states == [q] & labels == [a,b] & atoms == [final] &

(q,a) -> qa     & (q,b) -> qb     & 
(qa,a) -> q     & (qa,b) -> qab   &
(qb,a) -> qab   & (qb,b) -> qbb   & 
(qab,a) -> qb   & (qab,b) -> qabb &
(qbb,a) -> qabb & (qbb,b) -> q    &
(qabb,a) -> qbb & (qabb,b) -> qa  &

final -> q <+> qb &

(Sat(at)$st <==> at `in` out$st) &

(unfold(st)[] <==> Sat(final)$st) &	
(unfold(st)(x:w) <==> (x<>rel(st,unfold(st)(w)))$st) & 

UNFOLD(q)[] &
UNFOLD(qb)[] &
(UNFOLD(st)(x:w) <=== (st,x) -> st' & UNFOLD(st')(w))

-- widget interpreters

& drawL == wtree(1,fun((eps,k,n),text$eps,
                       (st,k,n),ite(Int$st,
				    color(k,n)$circ$11,
				    frame$blue$text$st)))

& drawC == wtree $ fun(eps,gif(cat,11,11),x,text$x) 

conjects:

unfold(q)[] &			--> True	-- simplify
unfold(q)[b] &			--> True
unfold(q)[b,b] &		--> False
unfold(q)[a,b,a,b,a,b,a] &	--> True
unfold(q)[a,b,a,b,b,a,b,a] &	--> False
unfold(qb)[a,b,a,a,b,a] &	--> True
unfold(qab)[a,b,a,b,a] &	--> True

UNFOLD(q)[] &			--> True	-- unify&narrow&
UNFOLD(q)[b] &			--> True	-- derive&simplify&refute
UNFOLD(q)[b,b] &		--> False
UNFOLD(q)[a,b,a,b,a,b,a] &	--> True	
UNFOLD(q)[a,b,a,b,b,a,b,a] &	--> False
UNFOLD(qb)[a,b,a,a,b,a] &	--> True
UNFOLD(qab)[a,b,a,b,a]		--> True

terms:

auto$reg <+>	--> non-deterministic acceptor of reg 
pauto$reg	--> deterministic acceptor of reg   

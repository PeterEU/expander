-- LOG2

constructs:	A B C go
defuncts:     	conc enum
preds:  	sorted perm select
		actsABC actions
              	queens board safe
fovars: 	x y z s s' s'' b n act acts acts'

axioms:

  sorted[]
& sorted[x]
& (sorted(x:(y:s)) <=== x <= y & sorted(y:s))

& perm([],[])
& (perm(x:s,y:s') <=== select(x:s,y,s'') & perm(s'',s'))

& (actsABC(n,acts) <=== actions(n,A,B,C,acts))
& actions(0,x,y,z,[])
& (actions(suc(n),x,y,z,conc(acts,go(x,z):acts'))
	 <=== actions(n,x,z,y,acts) & actions(n,y,x,z,acts'))
& conc([],acts) = acts 
& conc(act:acts,acts') = act:conc(acts,acts')

{- recursive queens

& (queens(n,s) <=== board([1..n],s))
& board([],[])
& (board(x:s,y:s')
         <=== select(x:s,y,s'') & board(s'',s') & safe(y,1,s'))
-}

-- iterative queens

& (queens(n,s) <=== board([1..n],[],s))
& board([],s,s)
& (board(x:s,s',b)
         <=== select(x:s,y,s'') & safe(y,1,s') & board(s'',y:s',b))

& (safe(x,n,[])  <==> True)
& (safe(x,n,y:s) <==> x =/= y+n & y =/= x+n & safe(x,n+1,s))

& select(x:s,x,s)
& (select(x:s,y,x:s') <=== select(s,y,s'))

conjects:

  sorted[1,3,4]
& select([1..4],x,s)
& perm([1,3,4],s)
    --> s = [1,3,4] | s = [1,4,3] | s = [3,1,4] | 
    --> s = [3,4,1] | s = [4,1,3] | s = [4,3,1]
& actsABC(3,acts) 
    --> acts = [go(A,C),go(A,B),go(C,B),go(A,C),go(B,A),go(B,C),go(A,C)]
& queens(4,s)


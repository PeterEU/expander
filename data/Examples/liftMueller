-- labels

preds: Visited Requested EF AF EX AG EG AU EU
constructs: UP DOWN L U go
defuncts: procs start lg states labels floor requests N
fovars: dir n ys xs s st

axioms:

N == 3 &
start == UP^0^L[]^U[] & states == [start] &
labels == [go,0,1,2] &

--- Transition system ---

-- Moving of the elevator
(dir^n^L[]^U[],go) -> dir^n^L[]^U[] &
((n+1 `NOTin` ys & n+1 < N & ys =/= []) 
  ==> (UP^n^L(xs)^U(ys),go) -> UP^n+1^L(xs)^U(ys)) &
((n+1 `in` (ys) & n+1 < N) 
  ==> (UP^n^L(xs)^U(ys),go) -> UP^n+1^L(xs)^U(ys-[n+1])) &
((n-1 `NOTin` xs & n-1 >= 0 & xs =/= []) 
  ==> (DOWN^n^L(xs)^U(ys),go) -> DOWN^n-1^L(xs)^U(ys)) &
((n-1 `in` (xs) & n-1 >= 0) 
  ==> (DOWN^n^L(xs)^U(ys),go) -> DOWN^n-1^L(xs-[n-1])^U(ys)) &
((n-1 `NOTin` xs & xs =/= [] & (ys = [])) 
  ==> (UP^n^L(xs)^U(ys),go) -> DOWN^n-1^L(xs)^U(ys)) &
((n-1 `in` (xs) & xs =/= [] & (ys = [])) 
  ==> (UP^n^L(xs)^U(ys),go) -> DOWN^n-1^L(xs-[n-1])^U(ys)) &
((n+1 `NOTin` ys & ys =/= [] & (xs = [])) 
  ==> (DOWN^n^L(xs)^U(ys),go) -> UP^n+1^L(xs)^U(ys)) &
((n+1 `in` (ys) & ys =/= [] & (xs = []))
  ==> (DOWN^n^L(xs)^U(ys),go) -> UP^n+1^L(xs)^U(ys-[n+1])) &

-- Requests for a storey
((s =/= go & s = n) ==> (dir^n^L[]^U[],s) -> dir^n^L[]^U[]) &
((s =/= go & s < n) ==> (dir^n^L[]^U[],s) -> dir^n^L[s]^U[]) &
((s =/= go & s > n) ==> (dir^n^L[]^U[],s) -> dir^n^L[]^U(s:[])) &
((s =/= go & s = n) ==> (dir^n^L[]^U(x:xs),s) -> dir^n^L[]^U(x:xs)) &
((s =/= go & s = n) ==> (dir^n^L(x:xs)^U[],s) -> dir^n^L(x:xs)^U[]) &
((s =/= go & s > n) ==> (dir^n^L(x:xs)^U[],s) -> dir^n^L(x:xs)^U[s]) &
((s =/= go & s < n & s `NOTin` xs & x =/= s) 
  ==> (dir^n^L(x:xs)^U[],s) -> dir^n^L(s:x:xs)^U[]) &
((s =/= go & s < n & s `NOTin` xs & x =/= s) 
  ==> (dir^n^L[]^U(x:xs),s) -> dir^n^L[s]^U(x:xs)) & 
((s =/= go & s > n & s `NOTin` xs & x =/= s) 
  ==> (dir^n^L[]^U(x:xs),s) -> dir^n^L[]^U(s:x:xs)) & 
((s =/= go & s = n) ==> (dir^n^L(y:ys)^U(x:xs),s) -> dir^n^L(y:ys)^U(x:xs)) &
((s =/= go & s < n & s `NOTin` ys & y =/= s) 
  ==> (dir^n^L(y:ys)^U(x:xs),s) -> dir^n^L(s:y:ys)^U(x:xs)) &
((s =/= go & s > n & s `NOTin` xs & x =/= s) 
  ==> (dir^n^L(y:ys)^U(x:xs),s) -> dir^n^L(y:ys)^U(s:x:xs))&
((s =/= go & (s `in` xs | s `in` ys))
  ==> (dir^n^L(xs)^U(ys),s) -> dir^n^L(xs)^U(ys)) & 

--- Relations and Atoms ---
(Requested(s,st) <==> s `in` requests$st) & 
--requested(x) -> branch$filter(rel(st,Requested(x,st)))$states &


(Visited(s,st) <==> s = floor$st) &
--visited(x) -> branch$filter(rel(st,Visited(x,st)))$states &

requests(dir^n^L(xs)^U(ys)) == xs ++ ys & 
floor(dir^n^L(xs)^U(ys)) == n

theorems:


conjects:

--Served(x) ===> atom(requested(x)) `EU` atom(visited(x))

-- modal

defuncts: states atoms labels out children parents mkfun valid
preds:    X R sat val outL childrenL -> or and EX AX XE XA <> >< <<>> # ## ###
	  EF AF FE FA `EU` `AU` `then` pi1 pi2 << >> child childF parent
	  sibling descendant ancestor related inv ; plus step tab
	  proj prod - exists forall / // sjoin njoin tjoin * lift eqstate 
copreds:  ~ AG EG GE GA `EW` `AW` `ER` `AR`
fovars:   st st' lab labs
hovars:   X R

axioms:

   procs == [0..noProcs-1]    -- used in many specifications that import modal

-- simplification of state formulas

 & (sat(P)$st <==> st`in`eval$P)	-- characteristic function of P

 & mkfun(R)$st == map(get1)$filter((=st).get0)(R)

 & (exists(R,P)$st <==> any(P)$mkfun(evalR$R)$st)
 & (forall(R,P)$st <==> all(P)$mkfun(evalR$R)$st)

 & (child(labs)(st,st') <==> st'`in`children(labs)$st)
 & (parent(labs)(st,st') <==> st'`in`parents(labs)$st)

 & (true$st <==> True)
 & (false$st <==> False)
 & (not(P)$st <==> Not(P$st))
 & ((P/\Q)$st <==> P$st & Q$st)
 & ((P\/Q)$st <==> P$st | Q$st)

-- derived modal formulas

 & (P`then`Q <==> not(P)\/Q)
 & (or <==> foldl(\/)$false)
 & (and <==> foldl(/\)$true)

 & (parent <==> inv.child)

 & (sibling(labs) <==> child(labs);parent$labs)

 & (EX$P <==> []<>P)
 & (XE$P <==> []><P)
 & (AX$P <==> []#P)
 & (XA$P <==> []##P)

 & (labs<>P <==> exists(child$labs,P))
 & (labs><P <==> exists(parent$labs,P))
 & (labs#P <==> forall(child$labs,P))
 & (labs##P <==> forall(parent$labs,P))

 & (R<<>>P <==> exists(childF$R,P))
 & (R###P <==> forall(childF$R,P))
 & (P<<R <==> P/\pi1$R)
 & (R>>P <==> P/\pi2$R)

 & (EF$P <==> MU X.(P\/EX$X))		     -- forward finally on some path
 & (FE$P <==> MU X.(P\/XE$X))		     -- backwards finally on some path
 & (AF$P <==> MU X.(P\/(AX(X)/\EX$true)))    -- forward finally on all paths 	
 & (FA$P <==> MU X.(P\/(XA(X)/\XE$true)))    -- backwards finally on all paths 	
 & (EG$P <==> NU X.(P/\(EX(X)\/AX$false)))   -- forward generally on some path
 & (GE$P <==> NU X.(P/\(XE(X)\/XA$false)))   -- backwards generally on some path
 & (AG$P <==> NU X.(P/\AX$X))		     -- forward generally on all paths
 & (GA$P <==> NU X.(P/\XA$X))		     -- backwards generally on all paths

 & ((P`EU`Q) <==> MU X.(Q\/(P/\EX$X)))	     -- until
 & ((P`AU`Q) <==> MU X.(Q\/(P/\AX$X)))		
 & ((P`EW`Q) <==> NU X.(Q\/(P/\EX$X)))       -- weak until
 & ((P`AW`Q) <==> NU X.(Q\/(P/\AX$X)))
 & ((P`ER`Q) <==> NU X.(Q/\(P\/EX$X)))       -- release
 & ((P`AR`Q) <==> NU X.(Q/\(P\/AX$X)))

 & (plus(R) <==> MU X.(R\/(R;X)))	     -- transitive closure of R

 & (descendant <==> plus.child)
 & (ancestor <==> plus.parent)

 & (related(labs) <==> ancestor(labs);sibling(labs);descendant$labs)

-- narrowing of state formulas

 & (EF(P)$st <=== P$st | EX(EF$P)$st)	     -- forward finally on some path  	   
 & (AG(P)$st ===> P$st & AX(AG$P)$st)	     -- forward generally on all paths
 & (AF(P)$st <=== P$st | AX(AF$P)$st & EX(true)$st)	
					     -- forward finally on all paths   	
 & (EG(P)$st ===> P$st & (EX(EG$P)$st | AX(false)$st)) 	
					     -- forward generally on some path
 & (FE(P)$st <=== P$st | XE(FE$P)$st)	     -- backwards finally on some path	 
 & (GA(P)$st ===> P$st & XA(GA$P)$st)	     -- backwards generally on all paths
 & (FA(P)$st <=== P$st | XA(FA$P)$st & XE(true)$st)		
					     -- backwards finally on all paths
 & (GE(P)$st ===> P$st & (XE(GE$P)$st | XA(false)$st)) 	
					     -- backwards generally on some path
	
 & ((P`EU`Q)$st <=== Q$st | P$st & EX(P`EU`Q)$st)	-- until
 & ((P`AU`Q)$st <=== Q$st | P$st & AX(P`AU`Q)$st)		
 & ((P`EW`Q)$st ===> Q$st | P$st & EX(P`EW`Q)$st)	-- weak until
 & ((P`AW`Q)$st ===> Q$st | P$st & AX(P`AW`Q)$st)	
 & ((P`ER`Q)$st ===> Q$st & (P$st | EX(P`ER`Q)$st))	-- release
 & ((P`AR`Q)$st ===> Q$st & (P$st | AX(P`AR`Q)$st))

-- state equivalence

 & (step(R)(st,st') <==> out[]$st = out[]$st' & outL(st,st') &
			 allany(R)(children[]$st,children[]$st') &
			 childrenL(R)(st,st'))

 & (outL(st,st') <==> all(rel(lab,out[lab]$st=out[lab]$st'))$labels)
 & (childrenL(R)(st,st') <==> 
     		      all(rel(lab,allany(R)(children[lab]$st,
                                            children[lab]$st')))$labels)

 & (eqstate <==> NU X.step$X)
 & (st ~ st' ===> step(~)(st,st'))


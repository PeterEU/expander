-- /Users/Padawitz/ExpanderLib/mergesortP

0. Derivation of

mergesort(s) = s' ==> sorted(s') & s ~ s'

All simplifications are admitted.
Equation removal is safe.

1. Adding

  (mergesort0(s,s') ===> sorted(s') & s ~ s')

to the axioms and applying FIXPOINT INDUCTION wrt

  mergesort[] = []
& mergesort[x] = [x]
& (mergesort(x:(y:s)) = merge(z3,z4) <=== 
   split(s) = (s1,s2) & mergesort(x:s1) = z3 & mergesort(y:s2) = z4)

at positions
[]
of the preceding trees leads to 

All x z3 z4 y s s1 s2:
 sorted[] & 
All x z3 z4 y s s1 s2:
 ([] ~ []) & 
All x z3 z4 y s s1 s2:
 sorted[x] & 
All x z3 z4 y s s1 s2:
 ([x] ~ [x]) & 
All x z3 z4 y s s1 s2:
 ((sorted(merge(z3,z4)) & (x:(y:s)) ~ merge(z3,z4) <=== 
   split(s) = (s1,s2) & mergesort0(x:s1,z3) & mergesort0(y:s2,z4)))

2. SIMPLIFYING parallel the preceding trees (one step) leads to 

sorted[] & [] ~ [] & All x:sorted[x] & All x:([x] ~ [x]) & 
All x z3 z4 y s s1 s2:
 ((split(s) = (s1,s2) & mergesort0(x:s1,z3) & mergesort0(y:s2,z4) ==> 
   sorted(merge(z3,z4)) & (x:(y:s)) ~ merge(z3,z4)))

3. Applying the axioms

  sorted[]
& (s ~ s' <=== bag(s) = bag(s'))
& sorted[x]

at positions
[3,0]
[2,0]
[1]
[0]
of the preceding trees leads to 

True & bag[] = bag[] & All x:True & All x:(bag[x] = bag[x]) & 
All x z3 z4 y s s1 s2:
 ((split(s) = (s1,s2) & mergesort0(x:s1,z3) & mergesort0(y:s2,z4) ==> 
   sorted(merge(z3,z4)) & (x:(y:s)) ~ merge(z3,z4)))

The axioms have been MATCHED against their redices.

4. SIMPLIFYING parallel the preceding trees (one step) leads to 

All x z3 z4 y s s1 s2:
 ((split(s) = (s1,s2) & mergesort0(x:s1,z3) & mergesort0(y:s2,z4) ==> 
   sorted(merge(z3,z4)) & (x:(y:s)) ~ merge(z3,z4)))

5. Applying the theorem

  (mergesort0(s,s') ===> sorted(s') & s ~ s')

at positions
[0,0,2]
[0,0,1]
of the preceding trees leads to 

All x z3 z4 y s s1 s2:
 ((split(s) = (s1,s2) & (sorted(z3) & (x:s1) ~ z3) & (sorted(z4) & (y:s2) ~ z4) ==> 
   sorted(merge(z3,z4)) & (x:(y:s)) ~ merge(z3,z4)))

The axioms have been MATCHED against their redices.

6. Applying the theorem

split(s) = (s1,s2) ===> s ~ (s1++s2)

at positions
[0,0,0]
of the preceding trees leads to 

All x z3 z4 y s s1 s2:
 ((s ~ (s1++s2) & (sorted(z3) & (x:s1) ~ z3) & (sorted(z4) & (y:s2) ~ z4) ==> 
   sorted(merge(z3,z4)) & (x:(y:s)) ~ merge(z3,z4)))

7. Applying the theorem

  (sorted(merge(s,s')) <=== sorted(s) & sorted(s'))

at positions
[0,1,0]
of the preceding trees leads to 

All x z3 z4 y s s1 s2:
 ((s ~ (s1++s2) & (sorted(z3) & (x:s1) ~ z3) & (sorted(z4) & (y:s2) ~ z4) ==> 
   (sorted(z3) & sorted(z4)) & (x:(y:s)) ~ merge(z3,z4)))

8. Applying the theorem

  (s ~ merge(s1,s2) <=== s ~ (s1++s2))

at positions
[0,1,1]
of the preceding trees leads to 

All x z3 z4 y s s1 s2:
 ((s ~ (s1++s2) & (sorted(z3) & (x:s1) ~ z3) & (sorted(z4) & (y:s2) ~ z4) ==> 
   (sorted(z3) & sorted(z4)) & (x:(y:s)) ~ (z3++z4)))

9. SIMPLIFYING parallel the preceding trees (2 steps) leads to 

All x z3 z4 y s s1 s2:
 ((s ~ (s1++s2) & sorted(z3) & (x:s1) ~ z3 & sorted(z4) & (y:s2) ~ z4 ==> 
   (x:(y:s)) ~ (z3++z4)))

10. Applying the theorem

  ((x:(y:s)) ~ (z3++z4) <=== s ~ (s1++s2) & (x:s1) ~ z3 & (y:s2) ~ z4)

at positions
[0,1]
of the preceding trees leads to 

All x z3 z4 y s s1 s2:
 ((s ~ (s1++s2) & sorted(z3) & (x:s1) ~ z3 & sorted(z4) & (y:s2) ~ z4 ==> 
   Any s18 s19:
    ((s ~ (s18++s19) & (x:s18) ~ z3 & (y:s19) ~ z4))))

11. SIMPLIFYING parallel the preceding trees (2 steps) leads to 

True

